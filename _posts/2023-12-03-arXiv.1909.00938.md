---
layout: post
title: "Notes for the Paper \"DECO: Liberating Web Data Using Decentralized Oracles for TLS\""
categories: [paper-reading]
tags: [blockchain, zero-knowledge]
---

DECO is a privacy-preserving, decentralized oracle scheme based on TLS.
It allows users to prove that a piece of data accessed via TLS came from a particular website,
and optional keeping the data itself secret.
And it requires no trusted hardware or server-side modifications. \
\
In this article, I will read the paper from an engineer's perspective, focus on its implementation;
theory details, such as proofs, will be ignored.

## The DECO Protocol

In the original paper, the authors build the full protocol from a strawman protocol, increase features step by step.
This article will skip those steps and focus on the final full protocol.

There are different approaches for each phase in the original paper.
I won't talk about all of them.
For exposition, I will only talk about all 1st choices in the original paper.

The following list shows which will mentioned in this article.
- Background
  - [MtA protocol](#mta-protocol)
  - [HMAC and PRF](#hmac-and-prf)
- Three-party handshake
  - TLS protocol
    - AES cipher
      - [x] CBC-HMAC mode
      - [ ] GCM mode (Sec. 4.1.2 in [DECO])
    - TLS version
      - [x] TLS 1.2
      - [ ] TLS 1.3 (Sec. 4.1.2 in [DECO])
- Query execution
  - [x] CBC-HMAC
  - [ ] AES-GCM (Sec. 4.2.2 in [DECO])
- Proof generation
  - [x] Selective opening
    - [x] CBC-HMAC
    - [ ] GCM (Sec. 5.1.2 in [DECO])
  - [ ] Context integrity (Sec. 5.2 in [DECO])

### Background

<div id="mta-protocol" />
#### Multiplicative to Additive (MtA) share conversion protocol[^1]

Let $E_{pk}(x)$ denote the encryption algorithm using public key $pk$.

- Given ciphertexts $c_{1} = E_{pk}(a)$ and $c_{2} = E_{pk}(b)$.

  <!-- FIXME(MathJax): underline after non-alphanumeric -->

  Computable function $+\_{E}$ such that: $c_{1} +\_{E} c_{2} = E_{pk}(a + b \mod{N})$.

- Given an integer $a \in N$ and a ciphertext $c = E_{pk}(m)$, then

  Scalar multiplication operation $\times_{E}$ such that:
  $a \times_{E} c_{i} = E_{pk}(am \mod{N})$.

The MtA protocol as follows:

- At the beginning,
  - Alice holds the secret $a \in Z_{q}$.
  - Bob holds the secret $b \in Z_{q}$.
  - $a$ and $b$ are multiplicative shares of a secret $s = ab \mod{q}$.
- Alice initiates the protocol by
  - sending $c_{A} = E_{A}(a)$ to Bob.
- Bob
  - chooses a random $\beta' \in Z_{q^{5}}$.
  - computes the ciphertext $c_{B} = b \times_{E} c_{A} +\_{E} E_{A}(\beta')$.
  - sets his share to $\beta = -\beta' \mod q$.
  - sending $c_{B}$ to Alice.
- Alice
  - decrypts $c_{B}$ to obtain $\alpha'$.
  - sets $\alpha = \alpha' \mod q$.
- As a result,
  - Alice holds $a$ and $\alpha$.
  - Bob holds $b$ and $\beta$.
  - $\alpha + \beta = s = ab \mod{q}$

<div id="hmac-and-prf" />
#### HMAC and The Pseudorandom Function (PRF) in TLS protocol[^2]

TLS's PRF takes as input a secret, a seed, and an identifying label and
produces an output of arbitrary length.

- Define a data expansion function:

  ```
  P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                         HMAC_hash(secret, A(2) + seed) +
                         HMAC_hash(secret, A(3) + seed) + ...
  ```

  where `+` indicates concatenation.

  And `A()` is defined as:
  ```
  A(0) = seed
  A(i) = HMAC_hash(secret, A(i-1))
  ```

- TLS's PRF is created by applying `P_hash` to the secret as:

  ```
  PRF(secret, label, seed) = P_hash(secret, label + seed)
  ```

### Three-party handshake

### Query execution

### Proof generation

#### Selective opening

## References

- [DECO: Liberating Web Data Using Decentralized Oracles for TLS][DECO]


---

[^1]: Section 3 in [Fast multiparty threshold ECDSA with fast trustless setup][Ref.42].
[^2]: Section 5 in [RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2][Ref.36].

[DECO]: https://arxiv.org/abs/1909.00938
[Ref.36]: https://www.rfc-editor.org/info/rfc5246
[Ref.42]: https://eprint.iacr.org/2019/114
